{"version":3,"sources":["../src/index.ts","../src/components/Editor/index.tsx","../src/components/Editor/useEditable.ts","../src/components/Live/LiveProvider.tsx","../src/components/Live/LiveContext.ts","../src/utils/transpile/index.ts","../src/utils/transpile/transform.ts","../src/utils/transpile/errorBoundary.tsx","../src/utils/transpile/evalCode.ts","../src/utils/transpile/compose.ts","../src/components/Live/LiveEditor.tsx","../src/components/Live/LiveError.tsx","../src/components/Live/LivePreview.tsx","../src/hoc/withLive.tsx"],"sourcesContent":["import Editor from \"./components/Editor\";\n\nimport LiveProvider from \"./components/Live/LiveProvider\";\nimport LiveEditor from \"./components/Live/LiveEditor\";\nimport LiveError from \"./components/Live/LiveError\";\nimport LivePreview from \"./components/Live/LivePreview\";\nimport LiveContext from \"./components/Live/LiveContext\";\n\nimport withLive from \"./hoc/withLive\";\n\nexport * from \"./utils/transpile\";\n\nexport {\n  Editor,\n  // Main exports:\n  LiveProvider,\n  LiveEditor,\n  LiveError,\n  LivePreview,\n  LiveContext,\n  withLive,\n};\n","import { Highlight, Prism, themes } from \"prism-react-renderer\";\nimport { CSSProperties, useEffect, useRef, useState } from \"react\";\nimport { useEditable } from \"./useEditable\";\n\nexport type Props = {\n  className?: string;\n  code: string;\n  disabled?: boolean;\n  language: string;\n  prism?: typeof Prism;\n  style?: CSSProperties;\n  tabMode?: \"focus\" | \"indentation\";\n  theme?: typeof themes.nightOwl;\n  onChange?(value: string): void;\n  id?: string;\n};\n\nconst CodeEditor = (props: Props) => {\n  const { tabMode = \"indentation\" } = props;\n  const editorRef = useRef(null);\n  const [code, setCode] = useState(props.code || \"\");\n  const { theme } = props;\n\n  useEffect(() => {\n    setCode(props.code);\n  }, [props.code]);\n\n  useEditable(editorRef, (text) => setCode(text.slice(0, -1)), {\n    disabled: props.disabled,\n    indentation: tabMode === \"indentation\" ? 2 : undefined,\n  }, props.id);\n\n  useEffect(() => {\n    if (props.onChange) {\n      props.onChange(code);\n    }\n  }, [code]);\n\n  return (\n    <div className={props.className} style={props.style}>\n      <Highlight\n        code={code}\n        theme={props.theme || themes.nightOwl}\n        language={props.language}\n      >\n        {({\n          className: _className,\n          tokens,\n          getLineProps,\n          getTokenProps,\n          style: _style,\n        }) => (\n          <pre\n            className={_className}\n            style={{\n              margin: 0,\n              outline: \"none\",\n              padding: 10,\n              fontFamily: \"inherit\",\n              ...(theme && typeof theme.plain === \"object\" ? theme.plain : {}),\n              ..._style,\n            }}\n            ref={editorRef}\n            spellCheck=\"false\"\n          >\n            {tokens.map((line, lineIndex) => (\n              <span key={`line-${lineIndex}`} {...getLineProps({ line })}>\n                {line\n                  .filter((token) => !token.empty)\n                  .map((token, tokenIndex) => (\n                    <span\n                      key={`token-${tokenIndex}`}\n                      {...getTokenProps({ token })}\n                    />\n                  ))}\n                {\"\\n\"}\n              </span>\n            ))}\n          </pre>\n        )}\n      </Highlight>\n    </div>\n  );\n};\n\nexport default CodeEditor;\n","import { useState, useLayoutEffect, useMemo } from 'react';\n\nexport interface Position {\n  position: number;\n  extent: number;\n  content: string;\n  line: number;\n}\n\ntype History = [Position, string];\n\nconst observerSettings = {\n  characterData: true,\n  characterDataOldValue: true,\n  childList: true,\n  subtree: true,\n};\n\nlet SHADOW_HOST_ID = '';\n\nconst getSelection = () => {\n  if(!SHADOW_HOST_ID) return window.getSelection();\n  \n  const shadowHost = document.querySelector(`#${SHADOW_HOST_ID}`);\n  const shadowRoot = shadowHost?.shadowRoot;\n\n  return shadowRoot?.getSelection();\n};\n\nconst getCurrentRange = () => getSelection()!.getRangeAt(0)!;\n\nconst setCurrentRange = (range: Range) => {\n  const selection = getSelection()!;\n  selection.empty();\n  selection.addRange(range);\n};\n\nconst isUndoRedoKey = (event: KeyboardEvent): boolean =>\n  (event.metaKey || event.ctrlKey) && !event.altKey && event.code === 'KeyZ';\n\nconst toString = (element: HTMLElement): string => {\n  const queue: Node[] = [element.firstChild!];\n\n  let content = '';\n  let node: Node;\n  while ((node = queue.pop()!)) {\n    if (node.nodeType === Node.TEXT_NODE) {\n      content += node.textContent;\n    } else if (node.nodeType === Node.ELEMENT_NODE && node.nodeName === 'BR') {\n      content += '\\n';\n    }\n\n    if (node.nextSibling) queue.push(node.nextSibling);\n    if (node.firstChild) queue.push(node.firstChild);\n  }\n\n  // contenteditable Quirk: Without plaintext-only a pre/pre-wrap element must always\n  // end with at least one newline character\n  if (content[content.length - 1] !== '\\n') content += '\\n';\n\n  return content;\n};\n\nconst setStart = (range: Range, node: Node, offset: number) => {\n  if (offset < node.textContent!.length) {\n    range.setStart(node, offset);\n  } else {\n    range.setStartAfter(node);\n  }\n};\n\nconst setEnd = (range: Range, node: Node, offset: number) => {\n  if (offset < node.textContent!.length) {\n    range.setEnd(node, offset);\n  } else {\n    range.setEndAfter(node);\n  }\n};\n\nconst getPosition = (element: HTMLElement): Position => {\n  // Firefox Quirk: Since plaintext-only is unsupported the position\n  // of the text here is retrieved via a range, rather than traversal\n  // as seen in makeRange()\n  const range = getCurrentRange();\n  const extent = !range.collapsed ? range.toString().length : 0;\n  const untilRange = document.createRange();\n  untilRange.setStart(element, 0);\n  untilRange.setEnd(range.startContainer, range.startOffset);\n  let content = untilRange.toString();\n  const position = content.length;\n  const lines = content.split('\\n');\n  const line = lines.length - 1;\n  content = lines[line];\n  return { position, extent, content, line };\n};\n\nconst makeRange = (\n  element: HTMLElement,\n  start: number,\n  end?: number\n): Range => {\n  if (start <= 0) start = 0;\n  if (!end || end < 0) end = start;\n\n  const range = document.createRange();\n  const queue: Node[] = [element.firstChild!];\n  let current = 0;\n\n  let node: Node;\n  let position = start;\n  while ((node = queue[queue.length - 1])) {\n    if (node.nodeType === Node.TEXT_NODE) {\n      const length = node.textContent!.length;\n      if (current + length >= position) {\n        const offset = position - current;\n        if (position === start) {\n          setStart(range, node, offset);\n          if (end !== start) {\n            position = end;\n            continue;\n          } else {\n            break;\n          }\n        } else {\n          setEnd(range, node, offset);\n          break;\n        }\n      }\n\n      current += node.textContent!.length;\n    } else if (node.nodeType === Node.ELEMENT_NODE && node.nodeName === 'BR') {\n      if (current + 1 >= position) {\n        if (position === start) {\n          setStart(range, node, 0);\n          if (end !== start) {\n            position = end;\n            continue;\n          } else {\n            break;\n          }\n        } else {\n          setEnd(range, node, 0);\n          break;\n        }\n      }\n\n      current++;\n    }\n\n    queue.pop();\n    if (node.nextSibling) queue.push(node.nextSibling);\n    if (node.firstChild) queue.push(node.firstChild);\n  }\n\n  return range;\n};\n\ninterface State {\n  observer: MutationObserver;\n  disconnected: boolean;\n  onChange(text: string, position: Position): void;\n  queue: MutationRecord[];\n  history: History[];\n  historyAt: number;\n  position: Position | null;\n}\n\nexport interface Options {\n  disabled?: boolean;\n  indentation?: number;\n}\n\nexport interface Edit {\n  /** Replaces the entire content of the editable while adjusting the caret position. */\n  update(content: string): void;\n  /** Inserts new text at the caret position while deleting text in range of the offset (which accepts negative offsets). */\n  insert(append: string, offset?: number): void;\n  /** Positions the caret where specified */\n  move(pos: number | { row: number; column: number }): void;\n  /** Returns the current editor state, as usually received in onChange */\n  getState(): { text: string; position: Position };\n}\n\nexport const useEditable = (\n  elementRef: { current: HTMLElement | undefined | null },\n  onChange: (text: string, position: Position) => void,\n  opts?: Options,\n  shadowHostId?: string\n): Edit => {\n  if (!opts) opts = {};\n  SHADOW_HOST_ID = shadowHostId || '';\n\n  const unblock = useState([])[1];\n  const state: State = useState(() => {\n    const state: State = {\n      observer: null as any,\n      disconnected: false,\n      onChange,\n      queue: [],\n      history: [],\n      historyAt: -1,\n      position: null,\n    };\n\n    if (typeof MutationObserver !== 'undefined') {\n      state.observer = new MutationObserver(batch => {\n        state.queue.push(...batch);\n      });\n    }\n\n    return state;\n  })[0];\n\n  const edit = useMemo<Edit>(\n    () => ({\n      update(content: string) {\n        const { current: element } = elementRef;\n        if (element) {\n          const position = getPosition(element);\n          const prevContent = toString(element);\n          position.position += content.length - prevContent.length;\n          state.position = position;\n          state.onChange(content, position);\n        }\n      },\n      insert(append: string, deleteOffset?: number) {\n        const { current: element } = elementRef;\n        if (element) {\n          let range = getCurrentRange();\n          range.deleteContents();\n          range.collapse();\n          const position = getPosition(element);\n          const offset = deleteOffset || 0;\n          const start = position.position + (offset < 0 ? offset : 0);\n          const end = position.position + (offset > 0 ? offset : 0);\n          range = makeRange(element, start, end);\n          range.deleteContents();\n          if (append) range.insertNode(document.createTextNode(append));\n          setCurrentRange(makeRange(element, start + append.length));\n        }\n      },\n      move(pos: number | { row: number; column: number }) {\n        const { current: element } = elementRef;\n        if (element) {\n          element.focus();\n          let position = 0;\n          if (typeof pos === 'number') {\n            position = pos;\n          } else {\n            const lines = toString(element).split('\\n').slice(0, pos.row);\n            if (pos.row) position += lines.join('\\n').length + 1;\n            position += pos.column;\n          }\n\n          setCurrentRange(makeRange(element, position));\n        }\n      },\n      getState() {\n        const { current: element } = elementRef;\n        const text = toString(element!);\n        const position = getPosition(element!);\n        return { text, position };\n      },\n    }),\n    []\n  );\n\n  // Only for SSR / server-side logic\n  if (typeof navigator !== 'object') return edit;\n\n  useLayoutEffect(() => {\n    state.onChange = onChange;\n\n    if (!elementRef.current || opts!.disabled) return;\n\n    state.disconnected = false;\n    state.observer.observe(elementRef.current, observerSettings);\n    if (state.position) {\n      const { position, extent } = state.position;\n      setCurrentRange(\n        makeRange(elementRef.current, position, position + extent)\n      );\n    }\n\n    return () => {\n      state.observer.disconnect();\n    };\n  });\n\n  useLayoutEffect(() => {\n    if (!elementRef.current || opts!.disabled) {\n      state.history.length = 0;\n      state.historyAt = -1;\n      return;\n    }\n\n    const element = elementRef.current!;\n    if (state.position) {\n      element.focus();\n      const { position, extent } = state.position;\n      setCurrentRange(makeRange(element, position, position + extent));\n    }\n\n    const prevWhiteSpace = element.style.whiteSpace;\n    const prevContentEditable = element.contentEditable;\n    let hasPlaintextSupport = true;\n    try {\n      // Firefox and IE11 do not support plaintext-only mode\n      element.contentEditable = 'plaintext-only';\n    } catch (_error) {\n      element.contentEditable = 'true';\n      hasPlaintextSupport = false;\n    }\n\n    if (prevWhiteSpace !== 'pre') element.style.whiteSpace = 'pre-wrap';\n\n    if (opts!.indentation) {\n      element.style.tabSize = (element.style as any).MozTabSize =\n        '' + opts!.indentation;\n    }\n\n    const indentPattern = `${' '.repeat(opts!.indentation || 0)}`;\n    const indentRe = new RegExp(`^(?:${indentPattern})`);\n    const blanklineRe = new RegExp(`^(?:${indentPattern})*(${indentPattern})$`);\n\n    let _trackStateTimestamp: number;\n    const trackState = (ignoreTimestamp?: boolean) => {\n      if (!elementRef.current || !state.position) return;\n\n      const content = toString(element);\n      const position = getPosition(element);\n      const timestamp = new Date().valueOf();\n\n      // Prevent recording new state in list if last one has been new enough\n      const lastEntry = state.history[state.historyAt];\n      if (\n        (!ignoreTimestamp && timestamp - _trackStateTimestamp < 500) ||\n        (lastEntry && lastEntry[1] === content)\n      ) {\n        _trackStateTimestamp = timestamp;\n        return;\n      }\n\n      const at = ++state.historyAt;\n      state.history[at] = [position, content];\n      state.history.splice(at + 1);\n      if (at > 500) {\n        state.historyAt--;\n        state.history.shift();\n      }\n    };\n\n    const disconnect = () => {\n      state.observer.disconnect();\n      state.disconnected = true;\n    };\n\n    const flushChanges = () => {\n      state.queue.push(...state.observer.takeRecords());\n      const position = getPosition(element);\n      if (state.queue.length) {\n        disconnect();\n        const content = toString(element);\n        state.position = position;\n        let mutation: MutationRecord | void;\n        let i = 0;\n        while ((mutation = state.queue.pop())) {\n          if (mutation.oldValue !== null)\n            mutation.target.textContent = mutation.oldValue;\n          for (i = mutation.removedNodes.length - 1; i >= 0; i--)\n            mutation.target.insertBefore(\n              mutation.removedNodes[i],\n              mutation.nextSibling\n            );\n          for (i = mutation.addedNodes.length - 1; i >= 0; i--)\n            if (mutation.addedNodes[i].parentNode)\n              mutation.target.removeChild(mutation.addedNodes[i]);\n        }\n\n        state.onChange(content, position);\n      }\n    };\n\n    const onKeyDown = (event: HTMLElementEventMap['keydown']) => {\n      if (event.defaultPrevented || event.target !== element) {\n        return;\n      } else if (state.disconnected) {\n        // React Quirk: It's expected that we may lose events while disconnected, which is why\n        // we'd like to block some inputs if they're unusually fast. However, this always\n        // coincides with React not executing the update immediately and then getting stuck,\n        // which can be prevented by issuing a dummy state change.\n        event.preventDefault();\n        return unblock([]);\n      }\n\n      if (isUndoRedoKey(event)) {\n        event.preventDefault();\n\n        let history: History;\n        if (!event.shiftKey) {\n          const at = --state.historyAt;\n          history = state.history[at];\n          if (!history) state.historyAt = 0;\n        } else {\n          const at = ++state.historyAt;\n          history = state.history[at];\n          if (!history) state.historyAt = state.history.length - 1;\n        }\n\n        if (history) {\n          disconnect();\n          state.position = history[0];\n          state.onChange(history[1], history[0]);\n        }\n        return;\n      } else {\n        trackState();\n      }\n\n      if (event.key === 'Enter') {\n        event.preventDefault();\n        // Firefox Quirk: Since plaintext-only is unsupported we must\n        // ensure that only newline characters are inserted\n        const position = getPosition(element);\n        // We also get the current line and preserve indentation for the next\n        // line that's created\n        const match = /\\S/g.exec(position.content);\n        const index = match ? match.index : position.content.length;\n        const text = '\\n' + position.content.slice(0, index);\n        edit.insert(text);\n      } else if (\n        (!hasPlaintextSupport || opts!.indentation) &&\n        event.key === 'Backspace'\n      ) {\n        // Firefox Quirk: Since plaintext-only is unsupported we must\n        // ensure that only a single character is deleted\n        event.preventDefault();\n        const range = getCurrentRange();\n        if (!range.collapsed) {\n          edit.insert('', 0);\n        } else {\n          const position = getPosition(element);\n          const match = blanklineRe.exec(position.content);\n          edit.insert('', match ? -match[1].length : -1);\n        }\n      } else if (opts!.indentation && event.key === 'Tab') {\n        event.preventDefault();\n        const position = getPosition(element);\n        const start = position.position - position.content.length;\n        const content = toString(element);\n        const newContent = event.shiftKey\n          ? content.slice(0, start) +\n            position.content.replace(indentRe, '') +\n            content.slice(start + position.content.length)\n          : content.slice(0, start) +\n            (opts!.indentation ? ' '.repeat(opts!.indentation) : '\\t') +\n            content.slice(start);\n        edit.update(newContent);\n      }\n\n      // Flush changes as a key is held so the app can catch up\n      if (event.repeat) flushChanges();\n    };\n\n    const onKeyUp = (event: HTMLElementEventMap['keyup']) => {\n      if (event.defaultPrevented || event.isComposing) return;\n      if (!isUndoRedoKey(event)) trackState();\n      flushChanges();\n      // Chrome Quirk: The contenteditable may lose focus after the first edit or so\n      element.focus();\n    };\n\n    const onSelect = (event: Event) => {\n      // Chrome Quirk: The contenteditable may lose its selection immediately on first focus\n      state.position =\n        getSelection()!.rangeCount && event.target === element\n          ? getPosition(element)\n          : null;\n    };\n\n    const onPaste = (event: HTMLElementEventMap['paste']) => {\n      event.preventDefault();\n      trackState(true);\n      edit.insert(event.clipboardData!.getData('text/plain'));\n      trackState(true);\n      flushChanges();\n    };\n\n    document.addEventListener('selectstart', onSelect);\n    window.addEventListener('keydown', onKeyDown);\n    element.addEventListener('paste', onPaste);\n    element.addEventListener('keyup', onKeyUp);\n\n    return () => {\n      document.removeEventListener('selectstart', onSelect);\n      window.removeEventListener('keydown', onKeyDown);\n      element.removeEventListener('paste', onPaste);\n      element.removeEventListener('keyup', onKeyUp);\n      element.style.whiteSpace = prevWhiteSpace;\n      element.contentEditable = prevContentEditable;\n    };\n  }, [elementRef.current!, opts!.disabled, opts!.indentation]);\n\n  return edit;\n};","import { useEffect, useState, ComponentType, PropsWithChildren } from \"react\";\nimport LiveContext from \"./LiveContext\";\nimport { generateElement, renderElementAsync } from \"../../utils/transpile\";\nimport { themes } from \"prism-react-renderer\";\n\ntype ProviderState = {\n  element?: ComponentType | null;\n  error?: string;\n};\n\ntype Props = {\n  code?: string;\n  disabled?: boolean;\n  enableTypeScript?: boolean;\n  language?: string;\n  noInline?: boolean;\n  scope?: Record<string, unknown>;\n  theme?: typeof themes.nightOwl;\n  transformCode?(code: string): void;\n};\n\nfunction LiveProvider({\n  children,\n  code = \"\",\n  language = \"tsx\",\n  theme,\n  enableTypeScript = true,\n  disabled = false,\n  scope,\n  transformCode,\n  noInline = false,\n}: PropsWithChildren<Props>) {\n  const [state, setState] = useState<ProviderState>({\n    error: undefined,\n    element: undefined,\n  });\n\n  async function transpileAsync(newCode: string) {\n    const errorCallback = (error: Error) => {\n      setState({ error: error.toString(), element: undefined });\n    };\n\n    // - transformCode may be synchronous or asynchronous.\n    // - transformCode may throw an exception or return a rejected promise, e.g.\n    //   if newCode is invalid and cannot be transformed.\n    // - Not using async-await to since it requires targeting ES 2017 or\n    //   importing regenerator-runtime... in the next major version of\n    //   react-live, should target ES 2017+\n    try {\n      const transformResult = transformCode ? transformCode(newCode) : newCode;\n      try {\n        const transformedCode = await Promise.resolve(transformResult);\n        const renderElement = (element: ComponentType) =>\n          setState({ error: undefined, element });\n\n        if (typeof transformedCode !== \"string\") {\n          throw new Error(\"Code failed to transform\");\n        }\n\n        // Transpilation arguments\n        const input = {\n          code: transformedCode,\n          scope,\n          enableTypeScript,\n        };\n\n        if (noInline) {\n          setState({ error: undefined, element: null }); // Reset output for async (no inline) evaluation\n          renderElementAsync(input, renderElement, errorCallback);\n        } else {\n          renderElement(generateElement(input, errorCallback));\n        }\n      } catch (error) {\n        return errorCallback(error as Error);\n      }\n    } catch (e) {\n      errorCallback(e as Error);\n      return Promise.resolve();\n    }\n  }\n\n  const onError = (error: Error) => setState({ error: error.toString() });\n\n  useEffect(() => {\n    transpileAsync(code).catch(onError);\n  }, [code, scope, noInline, transformCode]);\n\n  const onChange = (newCode: string) => {\n    transpileAsync(newCode).catch(onError);\n  };\n\n  return (\n    <LiveContext.Provider\n      value={{\n        ...state,\n        code,\n        language,\n        theme,\n        disabled,\n        onError,\n        onChange,\n      }}\n    >\n      {children}\n    </LiveContext.Provider>\n  );\n}\n\nexport default LiveProvider;\n","import { themes } from \"prism-react-renderer\";\nimport { ComponentType, createContext } from \"react\";\n\ntype ContextValue = {\n  error?: string;\n  element?: ComponentType | null;\n  code: string;\n  disabled: boolean;\n  language: string;\n  theme?: typeof themes.nightOwl;\n  onError(error: Error): void;\n  onChange(value: string): void;\n};\n\nconst LiveContext = createContext<ContextValue>({} as ContextValue);\n\nexport default LiveContext;\n","import React, { ComponentType } from \"react\";\nimport transform from \"./transform\";\nimport errorBoundary from \"./errorBoundary\";\nimport evalCode from \"./evalCode\";\nimport compose from \"./compose\";\nimport { Transform } from \"sucrase\";\n\nconst jsxConst = 'const _jsxFileName = \"\";';\nconst trimCode = (code: string) => code.trim().replace(/;$/, \"\");\nconst spliceJsxConst = (code: string) => code.replace(jsxConst, \"\").trim();\nconst addJsxConst = (code: string) => jsxConst + code;\nconst wrapReturn = (code: string) => `return (${code})`;\n\ntype GenerateOptions = {\n  code: string;\n  scope?: Record<string, unknown>;\n  enableTypeScript: boolean;\n};\n\nexport const generateElement = (\n  { code = \"\", scope = {}, enableTypeScript = true }: GenerateOptions,\n  errorCallback: (error: Error) => void\n) => {\n  /**\n   * To enable TypeScript we need to transform the TS to JS code first,\n   * splice off the JSX const, wrap the eval in a return statement, then\n   * transform any imports. The two-phase approach is required to do\n   * the implicit evaluation and not wrap leading Interface or Type\n   * statements in the return.\n   */\n\n  const firstPassTransforms: Transform[] = [\"jsx\"];\n  enableTypeScript && firstPassTransforms.push(\"typescript\");\n\n  const transformed = compose<string>(\n    addJsxConst,\n    transform({ transforms: [\"imports\"] }),\n    spliceJsxConst,\n    trimCode,\n    transform({ transforms: firstPassTransforms }),\n    wrapReturn,\n    trimCode\n  )(code);\n\n  return errorBoundary(\n    evalCode(transformed, { React, ...scope }),\n    errorCallback\n  );\n};\n\nexport const renderElementAsync = (\n  { code = \"\", scope = {}, enableTypeScript = true }: GenerateOptions,\n  resultCallback: (sender: ComponentType) => void,\n  errorCallback: (error: Error) => void\n  // eslint-disable-next-line consistent-return\n) => {\n  const render = (element: ComponentType) => {\n    if (typeof element === \"undefined\") {\n      errorCallback(new SyntaxError(\"`render` must be called with valid JSX.\"));\n    } else {\n      resultCallback(errorBoundary(element, errorCallback));\n    }\n  };\n\n  if (!/render\\s*\\(/.test(code)) {\n    return errorCallback(\n      new SyntaxError(\"No-Inline evaluations must call `render`.\")\n    );\n  }\n\n  const transforms: Transform[] = [\"jsx\", \"imports\"];\n  enableTypeScript && transforms.splice(1, 0, \"typescript\");\n\n  evalCode(transform({ transforms })(code), { React, ...scope, render });\n};\n","import { transform as _transform, Transform } from \"sucrase\";\n\nconst defaultTransforms: Transform[] = [\"jsx\", \"imports\"];\n\ntype Options = {\n  transforms?: Transform[];\n};\n\nexport default function transform(opts: Options = {}) {\n  const transforms = Array.isArray(opts.transforms)\n    ? opts.transforms.filter(Boolean)\n    : defaultTransforms;\n\n  return (code: string) => _transform(code, { transforms }).code;\n}\n","import React, { ComponentType, Component } from \"react\";\n\nconst errorBoundary = (\n  Element: ComponentType,\n  errorCallback: (error: Error) => void\n) => {\n  return class ErrorBoundary extends Component {\n    componentDidCatch(error: Error) {\n      errorCallback(error);\n    }\n\n    render() {\n      return typeof Element === \"function\" ? (\n        <Element />\n      ) : React.isValidElement(Element) ? (\n        Element\n      ) : null;\n    }\n  };\n};\n\nexport default errorBoundary;\n","import type { ComponentType } from \"react\";\n\nconst evalCode = (\n  code: string,\n  scope: Record<string, unknown>\n): ComponentType => {\n  const scopeKeys = Object.keys(scope);\n  const scopeValues = scopeKeys.map((key) => scope[key]);\n  return new Function(...scopeKeys, code)(...scopeValues);\n};\n\nexport default evalCode;\n","/**\n * Creates a new composite function that invokes the functions from right to left\n */\n\nexport default function compose<T>(...functions: ((...args: T[]) => T)[]) {\n  return functions.reduce(\n    (acc, currentFn) =>\n      (...args: T[]) =>\n        acc(currentFn(...args))\n  );\n}\n","import React, { useContext } from \"react\";\nimport LiveContext from \"./LiveContext\";\nimport Editor, { Props as EditorProps } from \"../Editor\";\n\nexport default function LiveEditor(props: Partial<EditorProps>) {\n  const { code, language, theme, disabled, onChange } = useContext(LiveContext);\n\n  return (\n    <Editor\n      theme={theme}\n      code={code}\n      language={language}\n      disabled={disabled}\n      onChange={onChange}\n      {...props}\n    />\n  );\n}\n","import React, { useContext } from \"react\";\nimport LiveContext from \"./LiveContext\";\n\nexport default function LiveError<T extends Record<string, unknown>>(props: T) {\n  const { error } = useContext(LiveContext);\n  return error ? <pre {...props}>{error}</pre> : null;\n}\n","import React, { useContext } from \"react\";\nimport LiveContext from \"./LiveContext\";\n\ntype Props<T extends React.ElementType = React.ElementType> = {\n  Component?: T;\n} & React.ComponentPropsWithoutRef<T>;\n\nfunction LivePreview<T extends keyof JSX.IntrinsicElements>(\n  props: Props<T>\n): JSX.Element;\nfunction LivePreview<T extends React.ElementType>(props: Props<T>): JSX.Element;\n\nfunction LivePreview({ Component = \"div\", ...rest }: Props): JSX.Element {\n  const { element: Element } = useContext(LiveContext);\n  return <Component {...rest}>{Element ? <Element /> : null}</Component>;\n}\nexport default LivePreview;\n","import React, { ComponentType } from \"react\";\nimport LiveContext from \"../components/Live/LiveContext\";\n\ntype Props = {\n  live: Record<string, unknown>;\n};\n\nexport default function withLive<T>(\n  WrappedComponent: ComponentType<T & Props>\n) {\n  const WithLive = (props: T) => (\n    <LiveContext.Consumer>\n      {(live) => <WrappedComponent live={live} {...props} />}\n    </LiveContext.Consumer>\n  );\n\n  WithLive.displayName = \"WithLive\";\n  return WithLive;\n}\n"],"mappings":"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","names":["import_react","state","import_react","import_react","import_react","_transform","import_react","import_jsx_runtime","React","React","import_jsx_runtime","import_react","import_jsx_runtime","import_react","import_jsx_runtime","import_react","import_jsx_runtime","Component","import_jsx_runtime"]}